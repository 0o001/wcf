// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

using System;
using System.IO;
using System.Net;
using System.Security.Cryptography.X509Certificates;
using System.ServiceModel;
using System.ServiceModel.Web;
using System.Text;
using X509Certificate2 = System.Security.Cryptography.X509Certificates.X509Certificate2;


namespace WcfService
{

    [ServiceContract]
    public interface ICrlService
    {
        [OperationContract]
        [WebGet]
        Stream GetCrl(string serialNum);
    }

    public class CrlService : ICrlService
    {
        public Stream GetCrl(string serialNum)
        {
            // The test.crl is generated by the cert util tool and will not expire until the root cert expires.
            // We should investigate if we can generate it in the run time. This is not a blocking issue.
            string downloadFilePath = @"c:\\WCFTest\\test.crl";
            WebOperationContext.Current.OutgoingResponse.ContentType = "application/octet-stream";

            return File.OpenRead(downloadFilePath);
        }
    }

    [ServiceContract]
    public interface IUtil
    {
        [OperationContract]
        byte[] GetClientCert(bool exportAsPem);

        [OperationContract]
        byte[] GetRootCert(bool exportAsPem);

        [OperationContract]
         string GetFQDN();

    }

    public class Util : IUtil
    {
        public byte[] GetClientCert(bool exportAsPem)
        {
            X509Certificate2 clientCert = CertificateFromSubject(StoreName.My, StoreLocation.LocalMachine, "WCF Client Certificate");
            if (exportAsPem)
            {
                return Encoding.ASCII.GetBytes(GetCertificateAsPem(clientCert));
            }
            else
            {
                return clientCert.Export(X509ContentType.Pfx, "test");
            }
 
        }

        public byte[] GetRootCert(bool exportAsPem)
        {
            X509Certificate2 rootCert = CertificateFromSubject(StoreName.Root, StoreLocation.LocalMachine, "DO_NOT_TRUST_WcfBridgeRootCA");
            if (exportAsPem)
            {
                return Encoding.ASCII.GetBytes(GetCertificateAsPem(rootCert));
            }
            else
            {
                return rootCert.RawData;
            }
 
        }

        public string GetFQDN()
        {
            return Dns.GetHostEntry("127.0.0.1").HostName;
        }

        // All certificates have installed on the server machine, including client cert by the cert util tool.
        public static X509Certificate2 CertificateFromSubject(StoreName name, StoreLocation location, string subjectName)
        {

            X509Store store = null;

            try
            {
                store = new X509Store(name, location);
                store.Open(OpenFlags.ReadOnly);
                X509Certificate2Collection foundCertificates = store.Certificates.Find(X509FindType.FindBySubjectName, subjectName, validOnly: true);
                return foundCertificates.Count == 0 ? null : foundCertificates[0];
            }
            finally
            {
                if (store != null)
                {
                    store.Close();
                }
            }
        }

        public static X509Certificate2 CertificateFromFridendlyName(StoreName name, StoreLocation location, string fridendlyName)
        {

            X509Store store = null;

            try
            {
                store = new X509Store(name, location);
                store.Open(OpenFlags.ReadOnly);

                X509Certificate2Collection foundCertificates = store.Certificates.Find(X509FindType.FindByIssuerName, "DO_NOT_TRUST_WcfBridgeRootCA", false);
                foreach (X509Certificate2 cert in foundCertificates)
                {
                    if (cert.FriendlyName == fridendlyName)
                    {
                        return cert;
                    }
                }
                return null;
            }
            finally
            {
                if (store != null)
                {
                    store.Close();
                }
            }
        }

        public static string GetCertificateAsPem(X509Certificate2 certificate)
        {
            string base64String = Convert.ToBase64String(certificate.RawData);

            const string header = "-----BEGIN CERTIFICATE-----\n";
            const string footer = "-----END CERTIFICATE-----";

            StringBuilder builder = new StringBuilder(base64String.Length + header.Length + footer.Length);

            int base64StringIndex = 0;
            builder.Append(header);
            while (base64StringIndex < base64String.Length)
            {
                int charactersToAppend = Math.Min(64, base64String.Length - base64StringIndex);

                builder.Append(base64String, base64StringIndex, charactersToAppend);

                // PEM dictates that this must be a \n, not OS-dependent 
                builder.Append('\n');

                base64StringIndex += charactersToAppend;
            }

            builder.Append(footer);

            return builder.ToString();
        }
    }
}